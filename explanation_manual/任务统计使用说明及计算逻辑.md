# 任务统计使用说明及计算逻辑

## 目录

1. [功能概述](#功能概述)
2. [界面布局说明](#界面布局说明)
3. [统计卡片使用说明](#统计卡片使用说明)
4. [任务趋势图使用说明](#任务趋势图使用说明)
5. [任务分布图使用说明](#任务分布图使用说明)
6. [数据导出功能](#数据导出功能)
7. [统计数据计算逻辑](#统计数据计算逻辑)
8. [常见问题解答](#常见问题解答)

## 功能概述

任务统计模块提供全面的任务数据分析功能，帮助用户了解任务完成情况、工作效率和任务分布。主要功能包括：

- **任务按时完成率统计**：展示指定时间段内任务的按时完成情况
- **平均完成任务时间统计**：计算完成任务所需的平均时间
- **任务完成趋势分析**：支持按日、周、月查看任务完成数量的变化趋势
- **任务类别和标签分布**：通过饼图或条形图展示任务的分类分布
- **数据导出功能**：支持导出图表和CSV格式的数据文件

## 界面布局说明

统计界面主要由三个部分组成：

1. **顶部标题栏**：显示"任务统计与报表"标题和"导出所有数据"按钮
2. **统计卡片区域**：展示任务按时完成率和平均完成时间等关键指标
3. **图表区域**：左侧为任务趋势图，右侧为任务分布图

## 统计卡片使用说明

### 1. 任务按时完成率卡片

**功能说明**：显示任务的按时完成情况统计

**参数设置**：
- 统计天数：通过数值选择器设置统计的天数范围（默认为30天）
- 更新按钮：点击后刷新统计数据

**显示内容**：
- 总任务数：系统中所有任务的总数
- 按时完成：在截止日期前完成的任务数量
- 完成率：按时完成任务占比的百分比

### 2. 平均完成任务时间卡片

**功能说明**：计算并显示完成任务所需的平均时间

**参数设置**：与完成率卡片共用统计天数设置

**显示内容**：
- 统计任务数：参与计算的已完成任务数量
- 平均小时/分钟：平均完成时间的具体数值
- 平均总时间：格式化后的总平均时间（小时和分钟）

## 任务趋势图使用说明

### 功能说明

展示指定时间段内任务完成数量的变化趋势，支持按日、周、月查看。

### 参数设置

- **统计周期**：下拉选择框，可选择「每日」、「每周」或「每月」
- **统计天数**：数值选择器，可设置7-365天的统计范围（默认30天）

### 操作按钮

- **导出图表**：将当前趋势图导出为PNG、JPG、SVG或PDF格式的图片文件
- **导出数据**：将趋势数据导出为CSV或TXT格式的文件

### 图表说明

- 横轴：时间（根据选择的周期显示日期、周起始日期或月份）
- 纵轴：完成的任务数量
- 图表类型：折线图，每个数据点用圆形标记表示

## 任务分布图使用说明

### 功能说明

展示任务的类别分布或标签分布情况，支持饼图和条形图两种展示方式。

### 参数设置

- **分布类型**：下拉选择框，可选择「类别分布」或「标签分布」
- **图表类型**：下拉选择框，可选择「饼图」或「条形图」

### 操作按钮

- **导出图表**：将当前分布图导出为PNG、JPG、SVG或PDF格式的图片文件
- **导出数据**：将分布数据导出为CSV或TXT格式的文件

### 图表说明

- **饼图**：直观展示各类别/标签的占比情况，显示百分比标签
- **条形图**：通过条形高度比较不同类别/标签的任务数量
- **数据限制**：最多显示前10个类别/标签，避免图表过于拥挤

## 数据导出功能

### 1. 导出所有数据

点击顶部标题栏右侧的「导出所有数据」按钮，系统将导出以下CSV文件到指定文件夹：

- 任务趋势_每日.csv：每日任务完成趋势数据
- 任务趋势_每周.csv：每周任务完成趋势数据
- 任务趋势_每月.csv：每月任务完成趋势数据
- 任务类别分布.csv：任务类别分布数据
- 任务标签分布.csv：任务标签分布数据
- 任务完成率和平均时间统计.csv：任务完成率和平均时间统计数据

### 2. 单个图表/数据导出

在各统计组件中，点击「导出图表」或「导出数据」按钮可以单独导出相应的数据：

- **导出图表**：打开文件保存对话框，选择格式和路径后保存
- **导出数据**：导出当前视图下的CSV数据文件

## 统计数据计算逻辑

### 1. 任务完成率计算

```python
# 核心计算逻辑
def get_completion_rate(self, days=30):
    # 获取已完成和超时任务
    completed_tasks = self.get_completed_tasks()
    overdue_tasks = self.get_overdue_tasks()
    
    # 计算时间范围
    today = date.today()
    start_date = today - timedelta(days=days)
    
    # 初始化计数器
    total_count = 0  # 有截止日期的任务总数
    on_time_count = 0  # 按时完成的任务数
    
    # 统计已完成任务
    for task in completed_tasks:
        # 检查任务创建时间是否在统计范围内
        created_dt = self.parse_datetime(task.get('create_time'))
        if created_dt and start_date <= created_dt.date() <= today:
            deadline_str = task.get('deadline')
            if deadline_str:  # 只考虑有截止日期的任务
                total_count += 1
                
                # 检查是否按时完成
                completed_time_str = task.get('done_time')
                if completed_time_str:
                    deadline_dt = self.parse_datetime(deadline_str)
                    completed_dt = self.parse_datetime(completed_time_str)
                    if deadline_dt and completed_dt:
                        # 完成时间早于或等于截止时间视为按时完成
                        if completed_dt <= deadline_dt:
                            on_time_count += 1
    
    # 统计超时任务（这些任务有截止日期但未按时完成）
    for task in overdue_tasks:
        created_dt = self.parse_datetime(task.get('create_time'))
        if created_dt and start_date <= created_dt.date() <= today:
            total_count += 1  # 超时任务计入总数，但不计入按时完成数
    
    # 计算完成率
    completion_rate = (on_time_count / total_count * 100) if total_count > 0 else 0
    
    return total_count, on_time_count, completion_rate
```

**计算规则**：
1. 只统计在指定时间段内创建的任务
2. 只考虑有截止日期的任务
3. 如果任务的完成时间早于或等于截止时间，则视为按时完成
4. 超时任务计入总数，但不计入按时完成数
5. 完成率 = (按时完成任务数 / 有截止日期的任务总数) × 100%
6. 如果没有符合条件的任务，完成率为0%

### 2. 平均完成任务时间计算

```python
# 核心计算逻辑
def get_average_completion_time(self, days=30):
    completed_tasks = self.get_completed_tasks()
    
    today = date.today()
    start_date = today - timedelta(days=days)
    
    total_hours = 0
    count = 0
    
    for task in completed_tasks:
        # 获取任务创建时间和完成时间
        created_time_str = task.get('create_time')
        completed_time_str = task.get('done_time')
        
        if created_time_str and completed_time_str:
            created_dt = self.parse_datetime(created_time_str)
            completed_dt = self.parse_datetime(completed_time_str)
            
            if created_dt and completed_dt:
                created_date = created_dt.date()
                # 只统计指定日期范围内创建的任务
                if start_date <= created_date <= today:
                    # 计算完成时间差（小时）
                    time_diff = completed_dt - created_dt
                    time_diff_hours = time_diff.total_seconds() / 3600
                    
                    total_hours += time_diff_hours
                    count += 1
    
    # 计算平均完成时间
    avg_hours = 0
    avg_minutes = 0
    
    if count > 0:
        avg_hours = total_hours / count
        # 转换为小时和分钟
        hours = int(avg_hours)
        minutes = int((avg_hours - hours) * 60)
        avg_hours, avg_minutes = hours, minutes
    
    return count, avg_hours, avg_minutes
```

**计算规则**：
1. 只统计在指定时间段内创建的已完成任务
2. 计算任务从创建到完成的时间差（以小时为单位）
3. 平均时间 = 所有任务完成时间总和 / 任务数量
4. 结果以整数小时和分钟表示
5. 如果没有符合条件的任务，平均值为0

### 3. 任务完成趋势计算

```python
# 核心计算逻辑
def get_completion_trend(self, period='daily', days=30):
    completed_tasks = self.get_completed_tasks()
    
    # 创建时间标签和值的映射
    trend_data = defaultdict(int)
    
    # 初始化日期范围内的数据
    today = date.today()
    start_date = today - timedelta(days=days)
    
    # 根据统计周期生成时间标签
    current_date = start_date
    while current_date <= today:
        # 根据周期格式化日期并初始化计数为0
        if period == 'daily':
            label = current_date.strftime('%Y-%m-%d')
            current_date += timedelta(days=1)
        elif period == 'weekly':
            # 调整到本周的周一
            adjusted_date = current_date - timedelta(days=current_date.weekday())
            label = adjusted_date.strftime('%Y-%m-%d')
            current_date += timedelta(weeks=1)
        elif period == 'monthly':
            label = current_date.strftime('%Y-%m')
            # 调整到下个月
            if current_date.month == 12:
                current_date = date(current_date.year + 1, 1, 1)
            else:
                current_date = date(current_date.year, current_date.month + 1, 1)
        
        trend_data[label] = 0
    
    # 统计已完成任务
    for task in completed_tasks:
        completed_time_str = task.get('done_time')
        if completed_time_str:
            completed_dt = self.parse_datetime(completed_time_str)
            if completed_dt:
                completed_date = completed_dt.date()
                # 只统计指定日期范围内的任务
                if start_date <= completed_date <= today:
                    # 根据统计周期格式化完成日期
                    label = self.format_date(completed_dt, period)
                    
                    if label in trend_data:
                        trend_data[label] += 1
    
    # 排序并返回结果
    sorted_items = sorted(trend_data.items())
    labels = [item[0] for item in sorted_items]
    values = [item[1] for item in sorted_items]
    
    return labels, values
```

**计算规则**：
1. 根据选择的统计周期（每日/每周/每月）生成时间范围标签
2. 初始化所有时间点的计数为0
3. 遍历所有已完成任务，将任务分配到对应的时间点
4. 对于每周统计，以周一作为周的起始日期
5. 返回排序后的时间标签和对应的任务数量

### 4. 任务类别分布计算

```python
# 核心计算逻辑
def get_category_distribution(self, task_type=None):
    # 获取对应类型的任务
    if task_type is None:
        # 获取所有任务
        all_tasks = []
        for task_list in self.get_all_tasks().values():
            all_tasks.extend(task_list)
    else:
        all_tasks = self.get_all_tasks().get(task_type, [])
    
    # 统计类别分布
    category_data = defaultdict(int)
    for task in all_tasks:
        category = task.get('category', '未分类')
        category_data[category] += 1
    
    # 排序并返回结果（按任务数量降序排列）
    sorted_items = sorted(category_data.items(), key=lambda x: x[1], reverse=True)
    categories = [item[0] for item in sorted_items]
    values = [item[1] for item in sorted_items]
    
    return categories, values
```

**计算规则**：
1. 可选择统计特定类型的任务（待办/已完成/超时）或所有任务
2. 统计每个类别的任务数量
3. 未设置类别的任务归类为「未分类」
4. 按任务数量降序排列，返回类别列表和对应数量

### 5. 任务标签分布计算

```python
# 核心计算逻辑
def get_label_distribution(self, task_type=None):
    # 获取对应类型的任务
    if task_type is None:
        # 获取所有任务
        all_tasks = []
        for task_list in self.get_all_tasks().values():
            all_tasks.extend(task_list)
    else:
        all_tasks = self.get_all_tasks().get(task_type, [])
    
    # 统计标签分布
    label_data = defaultdict(int)
    for task in all_tasks:
        labels = task.get('labels', [])
        if isinstance(labels, list):
            for label in labels:
                label_data[label] += 1
    
    # 排序并返回结果（按任务数量降序排列）
    sorted_items = sorted(label_data.items(), key=lambda x: x[1], reverse=True)
    labels = [item[0] for item in sorted_items]
    values = [item[1] for item in sorted_items]
    
    return labels, values
```

**计算规则**：
1. 可选择统计特定类型的任务或所有任务
2. 任务可能包含多个标签，每个标签单独计数
3. 统计每个标签出现的总次数
4. 按标签出现次数降序排列，返回标签列表和对应数量

## 常见问题解答

### 1. 为什么图表无法显示？

**可能原因**：
- matplotlib库未安装或版本不兼容
- PyQt5后端组件缺失

**解决方案**：
- 安装matplotlib：`pip install matplotlib`
- 安装PyQt5：`pip install PyQt5 PyQt5-sip`
- 重启应用程序

### 2. 为什么统计数据为空？

**可能原因**：
- 指定时间段内没有符合条件的任务
- 任务数据中缺少必要的时间字段

**解决方案**：
- 调整统计天数范围
- 检查任务是否包含完整的创建时间和完成时间

### 3. 如何导出高质量的图表图片？

**操作步骤**：
1. 点击图表下方的「导出图表」按钮
2. 在保存对话框中选择所需格式（SVG格式最适合高质量印刷）
3. 设置文件名和保存位置
4. 点击保存完成导出

### 4. 统计数据与实际情况不符怎么办？

**可能原因**：
- 任务数据不完整或有错误
- 日期时间格式不正确

**解决方案**：
- 检查任务数据的完整性，特别是时间字段
- 确保任务的创建时间、完成时间和截止日期格式正确
- 尝试使用「更新数据」按钮刷新统计